// --- THE CANON OF LOGOS (Standard Library) ---

// ==========================================
// I. THE BOOK OF NUMBERS (Mathematics)
// ==========================================

mystery abs(x: HolyInt) -> HolyInt {
    contemplate (x < 0) {
        aspect Verily: offer 0 - x;
        aspect Nay:    offer x;
    } amen
} amen

mystery max(a: HolyInt, b: HolyInt) -> HolyInt {
    contemplate (a > b) {
        aspect Verily: offer a;
        aspect Nay:    offer b;
    } amen
} amen

mystery min(a: HolyInt, b: HolyInt) -> HolyInt {
    contemplate (a < b) {
        aspect Verily: offer a;
        aspect Nay:    offer b;
    } amen
} amen

mystery pow(base: HolyInt, exp: HolyInt) -> HolyInt {
    contemplate (exp is 0) {
        aspect Verily: offer 1;
        aspect Nay:    offer base * pow(base, exp - 1);
    } amen
} amen

// ==========================================
// II. THE BOOK OF WORDS (String Manipulation)
// ==========================================

mystery is_empty(s: Text) -> Bool {
    offer measure(s) is 0;
} amen

mystery equals(s1: Text, s2: Text) -> Bool {
    offer s1 is s2;
} amen

mystery chant(s: Text, count: HolyInt) -> Text {
    contemplate (count <= 0) {
        aspect Verily: offer "";
        aspect Nay:    offer s + chant(s, count - 1);
    } amen
} amen

// ==========================================
// III. THE BOOK OF REVELATION (I/O Helpers)
// ==========================================

mystery say(msg: Text) {
    proclaim msg;
} amen

mystery say_int(n: HolyInt) {
    proclaim n;
} amen

// Note: supplicate prompts and reads a line of input.
mystery ask(prompt: Text) -> Text {
    inscribe response : Text = supplicate prompt;
    offer response;
} amen

mystery ask_int(prompt: Text) -> HolyInt {
    inscribe txt : Text = supplicate prompt;
    vigil {
        offer transfigure txt into HolyInt;
    } confess e {
        // If input is not a HolyInt, return 0 by convention.
        offer 0;
    } amen
} amen

// ==========================================
// IV. THE BOOK OF LOGIC (Boolean Helpers)
// ==========================================

mystery not(b: Bool) -> Bool {
    contemplate (b) {
        aspect Verily: offer Nay;
        aspect Nay:    offer Verily;
    } amen
} amen

mystery and(a: Bool, b: Bool) -> Bool {
    contemplate (a) {
        aspect Verily: offer b;
        aspect Nay:    offer Nay;
    } amen
} amen

mystery or(a: Bool, b: Bool) -> Bool {
    contemplate (a) {
        aspect Verily: offer Verily;
        aspect Nay:    offer b;
    } amen
} amen
